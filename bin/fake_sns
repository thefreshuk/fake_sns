#!/usr/bin/env ruby

lib = File.expand_path('../lib', __dir__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

require 'fake_sns'
require 'optparse'

options = {
  port: 9292,
  bind: '0.0.0.0',
  verbose: false,
  daemonize: false,
  database: nil,
  auto_drain: false,
  purge_on_drain: false,
  log: nil,
  update_hosts: false,
}

parser = OptionParser.new do |o|
  o.on '--database FILENAME', 'Place to store the database (defaults to ~/.fake_sns.yml)' do |filename|
    options[:database] = filename
  end

  o.on '-p', '--port PORT', Integer, "Port to use (default: #{options[:port]})" do |port|
    options[:port] = port
  end

  o.on '-o', '--bind HOST', 'Host to bind to (default: 0.0.0.0)' do |host|
    options[:bind] = host
  end

  o.on '-s', '--server SERVER', ['thin', 'mongrel', 'webrick'], 'Server to use: thin, mongrel or webrick (by default Sinatra chooses the best available)' do |server|
    options[:server] = server
  end

  o.on '-P', '--pid PIDFILE', 'Where to write the pid' do |pid|
    options[:pid] = pid
  end

  o.on '-d', '--[no-]daemonize', 'Detaches the process' do |daemonize|
    options[:daemonize] = daemonize
  end

  o.on '-v', '--[no-]verbose', 'Shows input parameters and output XML' do |verbose|
    options[:verbose] = verbose
  end

  o.on '-a', '--auto-drain', 'Auto-drains messages on publish' do |auto_drain|
    options[:auto_drain] = auto_drain
  end

  o.on '-x', '--purge-on-drain', 'Purges messages on drain' do |purge_on_drain|
    options[:purge_on_drain] = purge_on_drain
  end

  o.on '-L', '--log FILENAME', 'Logs to a file (STDOUT by default)' do |log|
    options[:log] = log
  end
  
  o.on '-i', '--update-hosts', 'Updates hosts file to add sns.aws.local to local ip' do |update_hosts|
    options[:update_hosts] = update_hosts
  end

  o.on_tail '--version', 'Shows the version' do
    puts "fake_sns version #{FakeSNS::VERSION}"
    exit
  end

  o.on_tail '-h', '--help', 'Shows this help page' do
    puts o
    exit
  end
end

parser.parse!

Process.daemon(true, true) if options[:daemonize]

if (pid = options[:pid])
  if File.exist?(pid)
    existing_pid = File.open(pid, 'r').read.chomp.to_i
    running = begin
                Process.getpgid(existing_pid)
              rescue StandardError
                false
              end
    if running
      warn "Error, Process #{existing_pid} already running"
      exit 1
    else
      warn "Cleaning up stale pid at #{pid}"
    end
  end
  File.open(pid, 'w') { |f| f.write(Process.pid) }
end

FakeSNS.server(options).run!
